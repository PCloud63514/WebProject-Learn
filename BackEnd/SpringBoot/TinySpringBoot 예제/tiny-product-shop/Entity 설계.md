# Entity 설계





---

##### 양방향 관계를 최대한 피하자

##### 다대다 관계(ManyToMany)를 피하자

##### Setter를 최대한 닫자.(객체의 불변성을 유지하자)

##### 모든 연관관계는 지연로딩으로 설정하자

> 즉시로딩(EAGER)는 예측이 어렵고, 어떤 SQL이 실행될지 추적이 어렵다.
>
> 예로 JPQL을 실행할 때 N + 1 문제가 자주 발생한다.
>
> 실무에서 모든 연관관계는 지연로딩(LAZY)로 설정해야한다.
>
> 연관된 Entity를 함께 DB에서 조회해야한다면, fetch, join 또는 Entity Graph 기능을 사용.
>
> @NToOne 관계는 기본이 즉시 로딩이므로 직접 지연로딩으로 설정해야한다.

##### 컬렉션은 필드에서 초기화하자

>  컬렉션은 필드레벨에서 바로 초기화하는 것이 null 문제에서 안전하다.
>
> 생성자에서 하나 필드레벨에서 초기화하나 같겠지만 하이버네이트가 Entity를 영속화 할 때, 컬렉션을 감싸서 내장 컬렉션으로 변경한다. 내부 메커니즘에 문제가 발생할 수 있으므로, 필드레벨이 가장 좋은 선택이다.
>
> 단 생성된 컬렉션은 sort 등 절대 건들지 말자 관리되고 있는 객체이기 때문에 건들면 DB 꼬인다.

---

#### 테이블, 컬럼명 생성 전략

SpringBoot에서 하이버네이트 기본 매핑 전략을 변경해서 실제 테이블 필드명과 다르도록한다.

entity를 만들 때 @Table(name=""), @Column이 안들어간 기본 값의 경우 하이버네이트의 테이블, 컬럼명 생성 전략은 다음과 같다.

1. 카멜 케이스 -> 언더스코어(memberPoint -> member_point)
2. .(점) -> _(언더스코어)
3. 대문자 -> 소문자



논리 명 생성: 명시적으로 테이블명, 컬럼을 작성하지 않으면 ImplicitNamingStrategy 사용

``` 
spring.jpa.hibernate.naming.implicit-strategy: 테이블, 컬럼 등 명시하지 않을 때 논리명 적용
```

물리명 적용:

```
spring.jpa.hibernate.naming.physical-strategy: 모든 논리명에 적용됨, 실제 테이블에 적용(username->usernm 등으로 회사 룰로 변경할 수 있음.)
```

